int main(int argc, char* *argv) {
  int opt;
  bool timing = false;
  bool batch = true; /* XXX implement repl and default to that */
  while ((opt = getopt(argc, argv, "h" "t" "b" DEBUG("d:"))) != -1) {
    switch (opt) {
    case 't':
      timing = true;
      break;
    case 'b':
      batch = true;
      break;
    DEBUG(case 'd':)
      DEBUG(debug_level = atoi(optarg);)
      DEBUG(assert(1 <= debug_level && debug_level <= 2);)
      DEBUG(break;)
    default:
      printf("Usage: %s option...\n"
             "Run Prolog queries from standard in.\n"
             "Options:\n\n"
             "  -b    Batch run the queries, print all results, and exit.\n"
             "        Do not use this for queries with an infinite number of answers.\n\n"
             "  -t    Time how long it takes to satisfy the query.\n\n"
       DEBUG("  -d N  Specify a debug level from 1 to 2.  Defaults to 2 (prints the most).\n\n")
             "This program was generated by toppl, a Prolog compiler.\n"
             , argv[0]);
      return EXIT_SUCCESS;
    }
  }

  char* err;

  predicate_t pred;
  memory_t mem;
  int32_t *addrs;
  va_mappings_t va_mappings;
  in_mappings_t in_mappings;

  runner_t runner;
  runner_state_t runner_state;
  memory_t *results;
  size_t n_results;

  int64_t timing_start = 0;
  int64_t timing_end;

  if (batch) {
    bool more_queries = true;
    while (true) {
      err = parse_query(&pred, &mem, &addrs, &va_mappings, &in_mappings, &more_queries);
      if (!more_queries) {
        break;
      }
      if (err != NULL) {
        goto err0;
      }
      err = find_predicate(&pred, &runner);
      if (err != NULL) {
        goto err0;
      }

      DEBUG
        ({
          debug("# parsed values\n");
          for (size_t i = 0; i < (size_t) pred.n_params; i++) {
            debug("arg[%lu] = mem[%d]\n", i, addrs[i]);
          }
          debug("\n");
          for (size_t i = 0; i < mem.n_cells; i++) {
            debug("mem[%lu] = ", i);
            debug_print_value(mem.cells[i]);
          }
          debug("\n");
        });

      if (timing) {
        timing_start = get_wall_time_us();
      }
      runner.init(&runner_state, addrs, &mem);
      bool more_unfinished = true;
      bool found_any_results = false;
      while (more_unfinished) {
        more_unfinished = runner.next(&runner_state, &results, &n_results);
        DEBUG(debug_n_nexts++;);
        print_results(results, n_results, &va_mappings, &in_mappings);
        if (n_results > 0) {
          found_any_results = true;
          for (size_t i = 0; i < n_results; i++) {
            free(results[i].cells);
          }
          free(results);
        }
      }
      if (!found_any_results) {
        puts("no");
      }
      if (timing) {
        timing_end = get_wall_time_us();
        int64_t timing_diff = timing_end - timing_start;
        fprintf(stderr, "timing: query took %lu microseconds\n", timing_diff);
      }
      free(pred.name);
      free(addrs);
      for (size_t i = 0; i < va_mappings.n_mappings; i++) {
        free(va_mappings.mappings[i].variable);
      }
      free(va_mappings.mappings);
      for (size_t i = 0; i < in_mappings.n_mappings; i++) {
        free(in_mappings.mappings[i].name);
      }
      free(in_mappings.mappings);

      DEBUG
        ({
          debug("# end\n");
          debug_print_nesting_inc();
          debug("n_nexts: %lu\n", debug_n_nexts);
          debug("max bytes: ");
          debug_print_human_size(debug_max_total_bytes);
        });
    }
  } else {
    /* XXX repl */
  }
  return EXIT_SUCCESS;

 err0:
  fprintf(stderr, "error: %s\n", err);
  return EXIT_FAILURE;
}
